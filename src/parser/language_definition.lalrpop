// Adapted from LALRPOP book examples
use std::str::FromStr;
use crate::ast::*;
use std::collections::HashMap;

grammar();

// Helpers
Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

// Shared
pub Name: String = {
    <s:r"[A-Za-z][A-Za-z0-9_\-]*"> => s.to_string()
};

// Full Template
pub Template: Template = {
    <mut t:Template> <f:Function> => {t.env.insert(f.0, f.1); t},
    <f: Function> => Template { env: HashMap::from([(f.0, f.1)]) }
};

// Function definitions
pub FunctionNameString: String = {
    "#" <s:Name> => s
};

pub Function: (String, Vec<Pattern>) = {
    <n: FunctionNameString> <p: Patterns> => (n, p),
};

Patterns: Vec<Pattern> = {
    <mut ps: Patterns> <p: Pattern> => { ps.push(p); ps },
    <p: Pattern> => vec![p],
};

pub Pattern: Pattern = {
    <e:Expr> ";" => Pattern {start: Expr::tuple(0, vec![], 0), result: e, guards: Vec::new()},
    <n:Expr> "->" <e:Expr> ";" => Pattern {start: n, result: e, guards: Vec::new()},
    <n:Expr> "->" <e:Expr> <g:Guards> ";" => Pattern {start: n, result: e, guards: g},
};

Guards: Vec<Guard> = {
    <mut gs: Guards> <g: Guard> => { gs.push(g); gs },
    <g: Guard> => vec![g],
};

pub Guard: Guard = {
    "|" <n:Expr>  => Guard {expr: n}
};

// String terms

pub StringTerm: String = {
    <s: r#""[^"]*""#> => s[1..s.len()-1].to_string()
};

StringInt: Vec<InterpolationPart> = {
    <s: r#"f"([^\{\}\\"]|\\\{|\\\}|\\\\|\\")*"f"#> => vec![InterpolationPart::String(s[2..s.len()-2].to_string())],
    <s1: r#"f"([^\{\}\\"]|\\\{|\\\}|\\\\|\\")*\{"#> <mut si: StringIntMid> <s2: r#"\}([^\{\}\\"]|\\\{|\\\}|\\\\|\\")*"f"#> => {
        si.insert(0, InterpolationPart::String(s1[2..s1.len()-1].to_string()));
        si.push(InterpolationPart::String(s2[1..s2.len()-2].to_string()));
        si
    },
};

StringIntMid: Vec<InterpolationPart> = {
    Expr => vec![InterpolationPart::Expr(<>)],
    <mut si: StringIntMid> <s: r#"\}([^\{\}\\"]|\\\{|\\\}|\\\\|\\")*\{"#> <e: Expr> => {
        si.push(InterpolationPart::String(s[1..s.len()-1].to_string()));
        si.push(InterpolationPart::Expr(e));
        si
    }
};

// Operations
pub Expr: Expr = {
    LogicExpr
};

LogicExpr: Expr = {
    @L EqualityExpr LogicOp AddSubExpr @R => Expr::op(<>),
    EqualityExpr,
};

LogicOp: Opcode = {
    "&&" => Opcode::And,
    "||" => Opcode::Or,
};

EqualityExpr: Expr = {
    @L EqualityExpr EqualityOp AddSubExpr @R => Expr::op(<>),
    AddSubExpr,
};

EqualityOp: Opcode = {
    "==" => Opcode::Eq,
    "!=" => Opcode::Neq,
    "<=" => Opcode::Leq,
    ">=" => Opcode::Geq,
    "<" => Opcode::Lt,
    ">" => Opcode::Gt,
};

AddSubExpr: Expr = {
    @L AddSubExpr AddSubExprOp Factor @R => Expr::op(<>),
    Factor,
};

AddSubExprOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

Factor: Expr = {
    @L Factor FactorOp Term @R => Expr::op(<>),
    CallTerm,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
    "%" => Opcode::Mod,
};

UnaryOp: UnaryOp = {
    "!" => UnaryOp::Not,
    "-" => UnaryOp::Neg,
};

CallTerm: Expr = {
    <l: @L> <e:CallTerm> "(" <l1:@L> <c: Comma<Expr>> <r1:@R> ")" <r:@R> => Expr::func_call(l, e, Expr::tuple(l1, c, r1), r),
    <t:Term> => t,
}

Term: Expr = {
    <l: @L> <m:"_"> <r:@R> => Expr::var(l, "_".to_string(), r),
    @L Name @R => Expr::var(<>),
    @L Num @R => Expr::number(<>),
    @L UnaryOp Term @R => Expr::unary(<>),
    <l:@L> "(" <v: Comma<Expr>> ")" <r:@R> => {
        if v.len() == 1 {
            v[0].clone()
        } else {
            Expr::tuple(<>)
        }
    },
    @L StringTerm @R => Expr::string(<>),
    @L StringInt @R => Expr::interpolation_string(<>),
    <l:@L> "|" <l1:@L> <s: Comma<Expr>> <r1:@L> "=>" <e: Expr> "|" <r:@R> => Expr::function(l, vec![Pattern { start: Expr::tuple(l1, s, r1), result: e, guards: vec![]}], r),
};

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap(),
};

match {
    r"\s*" => { }, // The default whitespace skipping is disabled an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
    _
}