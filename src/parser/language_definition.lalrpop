// Adapted from LALRPOP book examples
use std::str::FromStr;
use crate::ast::*;
use std::collections::HashMap;

grammar();

// Helpers
Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None=> v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

// Shared
pub Name: String = {
    <s:r"[A-Za-z][A-Za-z0-9_\-]*"> => s.to_string()
}

// Full Template
pub Template: Template = {
    <mut t:Template> <f:Function> => {t.functions.insert(f.name.clone(), f); t},
    <f: Function> => Template { functions: HashMap::from([(f.name, f)]) }
}

// Function definitions
pub FunctionNameString: String = {
    "#" <s:Name> => s
}

pub Function: Function = {
    <n: FunctionNameString> <p: Patterns> => Function { name: n, patterns: p },
}

Patterns: Vec<Pattern> = {
    <mut ps: Patterns> <p: Pattern> => { ps.push(p); ps },
    <p: Pattern> => vec![p],
}

pub Pattern: Pattern = {
    <n:Expr> "->" <e:Expr> ";" => Pattern {start: n, result: e, guards: Vec::new()},
    <n:Expr> "->" <e:Expr> <g:Guards> ";" => Pattern {start: n, result: e, guards: g},
}

Guards: Vec<Guard> = {
    <mut gs: Guards> <g: Guard> => { gs.push(g); gs },
    <g: Guard> => vec![g],
}

pub Guard: Guard = {
    "|" <n:Expr>  => Guard {expr: n}
}

// String terms

pub StringTerm: String = {
    <s: r#""[^"\n]*""#> => s[1..s.len()-1].to_string(),
    <s: r#""""[^"]*""""#> => s[3..s.len()-3].to_string(),
}

StringInt: Vec<InterpolationPart> = {
    <s: r#"f"([^\{\}\n]|\\\{|\\\})*"f"#> => vec![InterpolationPart::String(s[2..s.len()-2].to_string())],
    <s1: r#"f"[^\{\}\n]*\{"#> <mut si: StringIntMid> <s2: r#"\}[^\{\}\n]*"f"#> => {
        si.insert(0, InterpolationPart::String(s1[..s1.len()-1].to_string()));
        si.push(InterpolationPart::String(s2[1..].to_string()));
        si
    }
}

StringIntMid: Vec<InterpolationPart> = {
    Expr => vec![InterpolationPart::Expr(<>)],
    <mut si: StringIntMid> <s: r"\}[^\{\}\n]*\{"> <e: Expr> => {
        si.push(InterpolationPart::String(s[1..s.len()-1].to_string()));
        si.push(InterpolationPart::Expr(e));
        si
    }
}

// Operations
pub Expr: Box<Expr> = {
    LogicExpr
}

LogicExpr: Box<Expr> = {
    EqualityExpr LogicOp AddSubExpr => Box::new(Expr::Op(<>)),
    EqualityExpr,
}

LogicOp: Opcode = {
    "&&" => Opcode::And,
    "||" => Opcode::Or,
};

EqualityExpr: Box<Expr> = {
    EqualityExpr EqualityOp AddSubExpr => Box::new(Expr::Op(<>)),
    AddSubExpr,
}

EqualityOp: Opcode = {
    "==" => Opcode::Eq,
    "<=" => Opcode::Leq,
    ">=" => Opcode::Geq,
    "<" => Opcode::Lt,
    ">" => Opcode::Gt,
};

AddSubExpr: Box<Expr> = {
    AddSubExpr AddSubExprOp Factor => Box::new(Expr::Op(<>)),
    Factor,
};

AddSubExprOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

Factor: Box<Expr> = {
    Factor FactorOp Term => Box::new(Expr::Op(<>)),
    Term,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
    "%" => Opcode::Mod,
};

UnaryOp: UnaryOp = {
    "!" => UnaryOp::Not,
};

Term: Box<Expr> = {
    <n:Name> => Box::new(Expr::Var(n)),
    <n:Name> "(" <c: Comma<Expr>> ")" => Box::new(Expr::FuncCall(n, c)),
    Num => Box::new(Expr::Number(<>)),
    UnaryOp Term => Box::new(Expr::Unary(<>)),
    "(" <Expr> ")" => <>,
    "{" <Comma<Expr>> "}" => Box::new(Expr::Tuple(<>)),
    StringTerm => Box::new(Expr::Str(<>)),
    StringInt => Box::new(Expr::InterpolationString(<>)),
    "|" <Comma<Expr>> "=>" <Expr> "|" => Box::new(Expr::Lambda(<>)),
};

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap(),
};

match {
    r"\s*" => { }, // The default whitespace skipping is disabled an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
    _
}