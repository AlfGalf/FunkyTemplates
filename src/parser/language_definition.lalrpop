// Adapted from LALRPOP book examples
use std::str::FromStr;
use crate::ast::*;
use std::collections::HashMap;

grammar();

// Helpers
Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

// Shared
pub Name: String = {
    <s:r"[A-Za-z][A-Za-z0-9_\-]*"> => s.to_string()
};

// Full Template
pub Template: Template = {
    <mut t:Template> <f:Function> => {t.env.insert(f.0, f.1); t},
    <f: Function> => Template { env: HashMap::from([(f.0, f.1)]) }
};

// Function definitions
pub FunctionNameString: String = {
    "#" <s:Name> => s
};

pub Function: (String, Box<Expr>) = {
    <n: FunctionNameString> <p: Patterns> => (n, Box::new(Expr::Function(p))),
};

Patterns: Vec<Pattern> = {
    <mut ps: Patterns> <p: Pattern> => { ps.push(p); ps },
    <p: Pattern> => vec![p],
};

pub Pattern: Pattern = {
    <e:Expr> ";" => Pattern {start: Box::new(Expr::Tuple(vec![])), result: e, guards: Vec::new()},
    <n:Expr> "->" <e:Expr> ";" => Pattern {start: n, result: e, guards: Vec::new()},
    <n:Expr> "->" <e:Expr> <g:Guards> ";" => Pattern {start: n, result: e, guards: g},
};

Guards: Vec<Guard> = {
    <mut gs: Guards> <g: Guard> => { gs.push(g); gs },
    <g: Guard> => vec![g],
};

pub Guard: Guard = {
    "|" <n:Expr>  => Guard {expr: n}

};

// String terms

pub StringTerm: String = {
    <s: r#""[^"]*""#> => s[1..s.len()-1].to_string()
};

StringInt: Vec<InterpolationPart> = {
    <s: r#"f"([^\{\}]|\\\{|\\\})*"f"#> => vec![InterpolationPart::String(s[2..s.len()-2].to_string())],
    <s1: r#"f"([^\{\}]|\\\{|\\\})*\{"#> <mut si: StringIntMid> <s2: r#"\}([^\{\}]|\\\{|\\\})*"f"#> => {
        si.insert(0, InterpolationPart::String(s1[2..s1.len()-1].to_string()));
        si.push(InterpolationPart::String(s2[1..s2.len()-2].to_string()));
        si
    },
};

StringIntMid: Vec<InterpolationPart> = {
    Expr => vec![InterpolationPart::Expr(<>)],
    <mut si: StringIntMid> <s: r"\}([^\{\}]|\\\{|\\\})*\{"> <e: Expr> => {
        si.push(InterpolationPart::String(s[1..s.len()-1].to_string()));
        si.push(InterpolationPart::Expr(e));
        si
    }
};

// Operations
pub Expr: Box<Expr> = {
    LogicExpr
};

LogicExpr: Box<Expr> = {
    EqualityExpr LogicOp AddSubExpr => Box::new(Expr::Op(<>)),
    EqualityExpr,
};

LogicOp: Opcode = {
    "&&" => Opcode::And,
    "||" => Opcode::Or,
};

EqualityExpr: Box<Expr> = {
    EqualityExpr EqualityOp AddSubExpr => Box::new(Expr::Op(<>)),
    AddSubExpr,
};

EqualityOp: Opcode = {
    "==" => Opcode::Eq,
    "<=" => Opcode::Leq,
    ">=" => Opcode::Geq,
    "<" => Opcode::Lt,
    ">" => Opcode::Gt,
};

AddSubExpr: Box<Expr> = {
    AddSubExpr AddSubExprOp Factor => Box::new(Expr::Op(<>)),
    Factor,
};

AddSubExprOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

Factor: Box<Expr> = {
    Factor FactorOp Term => Box::new(Expr::Op(<>)),
    CallTerm,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
    "%" => Opcode::Mod,
};

UnaryOp: UnaryOp = {
    "!" => UnaryOp::Not,
};

CallTerm: Box<Expr> = {
    <e:CallTerm> "(" <c: Comma<Expr>> ")" => Box::new(Expr::FuncCall(e, c)),
    <t:Term> => t,
}

Term: Box<Expr> = {
    <n:Name> => Box::new(Expr::Var(n)),
    Num => Box::new(Expr::Number(<>)),
    UnaryOp Term => Box::new(Expr::Unary(<>)),
    "(" <v: Comma<Expr>> ")" => {
        if v.len() == 1 {
            Box::new(*v[0].clone())
        } else {
            Box::new(Expr::Tuple(<>))
        }
    },
    StringTerm => Box::new(Expr::Str(<>)),
    StringInt => Box::new(Expr::InterpolationString(<>)),
    "|" <s: Comma<Expr>> "=>" <e: Expr> "|" => Box::new(Expr::Function(vec![Pattern { start: Box::new(Expr::Tuple(s)), result: e, guards: vec![]}])),
};

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap(),
};

match {
    r"\s*" => { }, // The default whitespace skipping is disabled an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
    _
}