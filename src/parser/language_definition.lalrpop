// Adapted from LALRPOP book examples
use std::str::FromStr;
use crate::ast::*;

grammar();

// Helpers
Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None=> v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

// Shared
pub Name: String = {
    <s:r"[A-Za-z][A-Za-z0-9_\-]*"> => s.to_string()
}

// Full Template
pub Template: Template = {
    <mut t:Template> <f:Function> => {t.functions.push(f); t},
    Function => Template { functions: vec![<>] }
}

// Function definitions
pub FunctionNameString: String = {
    "#" <s:Name> => s
}

pub Function: Function = {
    <n: FunctionNameString> "\n" <p: Patterns> => Function { name: n, patterns: p },
}

Patterns: Vec<Pattern> = {
    <mut ps: Patterns> <p: Pattern> => { ps.push(p); ps },
    <p: Pattern> => vec![p],
}

pub Pattern: Pattern = {
    <n:Expr> "->" <e:Expr> "\n" <g: Guards> => Pattern {start: n, result: e, guards: g},
    <n:Expr> "->" <e:Expr> "\n" => Pattern {start: n, result: e, guards: Vec::new()},
}

Guards: Vec<Guard> = {
    <mut gs: Guards> "\n" <g: Guard> => { gs.push(g); gs },
    <g: Guard> => vec![g],
}

pub Guard: Guard = {
    "|" <n:Expr> "\n" => Guard {}
}

// String terms
pub StringTerm: String = {
    <s: r#""[^"\n]*""#> => s[1..s.len()-1].to_string()
}

// Operations

pub Expr: Box<Expr> = {
    LogicExpr
}

LogicExpr: Box<Expr> = {
    EqualityExpr LogicOp AddSubExpr => Box::new(Expr::Op(<>)),
    EqualityExpr,
}

LogicOp: Opcode = {
    "&&" => Opcode::And,
    "||" => Opcode::Or,
};

EqualityExpr: Box<Expr> = {
    EqualityExpr EqualityOp AddSubExpr => Box::new(Expr::Op(<>)),
    AddSubExpr,
}

EqualityOp: Opcode = {
    "==" => Opcode::Eq,
    "<=" => Opcode::Leq,
    ">=" => Opcode::Geq,
    "<" => Opcode::Lt,
    ">" => Opcode::Gt,
};

AddSubExpr: Box<Expr> = {
    AddSubExpr AddSubExprOp Factor => Box::new(Expr::Op(<>)),
    Factor,
};

AddSubExprOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

Factor: Box<Expr> = {
    Factor FactorOp Term => Box::new(Expr::Op(<>)),
    Term,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
    "%" => Opcode::Mod,
};

UnaryOp: UnaryOp = {
    "!" => UnaryOp::Not,
};

Term: Box<Expr> = {
    <n:Name> => Box::new(Expr::Var(n)),
    <n:Name> "(" <c: Comma<Expr>> ")" => Box::new(Expr::FuncCall(n, c)),
    Num => Box::new(Expr::Number(<>)),
    UnaryOp Term => Box::new(Expr::Unary(<>)),
    "(" <Expr> ")",
    "{" <Comma<Expr>> "}" => Box::new(Expr::Tuple(<>)),
};

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap(),
};

match {
    r"[ \t]*" => { }, // The default whitespace skipping is disabled an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
    _
}